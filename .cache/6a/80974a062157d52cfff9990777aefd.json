{"id":"node_modules/html-literal/build/src/index.js","dependencies":[{"name":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/html-literal/build/src/index.js.map","includedInParent":true,"mtime":1639451770074},{"name":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/html-literal/src/index.ts","includedInParent":true,"mtime":1639451770075},{"name":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/package.json","includedInParent":true,"mtime":1639597210061},{"name":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/html-literal/package.json","includedInParent":true,"mtime":1639451770074},{"name":"flatted","loc":{"line":6,"column":24},"parent":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/html-literal/build/src/index.js","resolved":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/flatted/esm/index.js"},{"name":"strip-indent","loc":{"line":7,"column":45},"parent":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/html-literal/build/src/index.js","resolved":"/Users/jeff/Projects/SavvyCoders/CapstoneProject/node_modules/strip-indent/index.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar flatted_1 = require(\"flatted\");\nvar strip_indent_1 = __importDefault(require(\"strip-indent\"));\n// html tag function, accepts simple values, arrays, promises\nfunction html(template) {\n    var expressions = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        expressions[_i - 1] = arguments[_i];\n    }\n    var result = \"\";\n    var i = 0;\n    // resolve each expression and build the result string\n    for (var _a = 0, template_1 = template; _a < template_1.length; _a++) {\n        var part = template_1[_a];\n        var expression = expressions[i++ - 1]; // this might be an array\n        var resolvedExpression = resolveExpression(expression);\n        result += \"\" + resolvedExpression + part;\n    }\n    // strip indentation and trim the result\n    return strip_indent_1.default(result).trim();\n}\nexports.default = html;\n// returns whether given value is likely a promise\n// tslint:disable-next-line:no-any\nfunction isPromise(p) {\n    return p !== undefined && p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n// resolves a concatenatable expression to a string (async)\nfunction resolveExpression(expression) {\n    // return empty string for undefined\n    if (expression === undefined) {\n        return \"\";\n    }\n    // return placeholder for promise\n    if (isPromise(expression)) {\n        // recursively resolve\n        return \"[promise]\";\n    }\n    // return placeholder for function\n    if (typeof expression === \"function\") {\n        return \"[function]\";\n    }\n    // handle arrays\n    if (Array.isArray(expression)) {\n        var items = [];\n        // resolve each item (might be promises as well)\n        for (var _i = 0, expression_1 = expression; _i < expression_1.length; _i++) {\n            var expressionItem = expression_1[_i];\n            items.push(resolveExpression(expressionItem));\n        }\n        // join with newline\n        return items.join(\"\\n\");\n    }\n    // return unmodified if got a string\n    if (typeof expression === \"string\") {\n        return expression;\n    }\n    // convert to string if got a number\n    if (typeof expression === \"number\") {\n        return expression.toString();\n    }\n    // return stringified value, handles circular references\n    return flatted_1.stringify(expression, undefined, 2);\n}\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,mCAAoC;AACpC,8DAAuC;AAWvC,6DAA6D;AAC7D,SAAwB,IAAI,CAAC,QAA8B;IAAE,qBAAgC;SAAhC,UAAgC,EAAhC,qBAAgC,EAAhC,IAAgC;QAAhC,oCAAgC;;IAC3F,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,IAAI,CAAC,GAAG,CAAC,CAAC;IAEV,sDAAsD;IACtD,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;QAAxB,IAAM,IAAI,iBAAA;QACb,IAAM,UAAU,GAAG,WAAW,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,yBAAyB;QAClE,IAAM,kBAAkB,GAAG,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAEzD,MAAM,IAAI,KAAG,kBAAkB,GAAG,IAAM,CAAC;KAC1C;IAED,wCAAwC;IACxC,OAAO,sBAAW,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;AACpC,CAAC;AAdD,uBAcC;AAED,kDAAkD;AAClD,kCAAkC;AAClC,SAAS,SAAS,CAAI,CAAM;IAC1B,OAAO,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC;AAChG,CAAC;AAED,2DAA2D;AAC3D,SAAS,iBAAiB,CAAC,UAA0B;IACnD,oCAAoC;IACpC,IAAI,UAAU,KAAK,SAAS,EAAE;QAC5B,OAAO,EAAE,CAAC;KACX;IAED,iCAAiC;IACjC,IAAI,SAAS,CAAsB,UAAU,CAAC,EAAE;QAC9C,sBAAsB;QACtB,OAAO,WAAW,CAAC;KACpB;IAED,kCAAkC;IAClC,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;QACpC,OAAO,YAAY,CAAC;KACrB;IAED,gBAAgB;IAChB,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QAC7B,IAAM,KAAK,GAA0B,EAAE,CAAC;QAExC,gDAAgD;QAChD,KAA6B,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;YAApC,IAAM,cAAc,mBAAA;YACvB,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC,CAAC;SAC/C;QAED,oBAAoB;QACpB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACzB;IAED,oCAAoC;IACpC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAClC,OAAO,UAAU,CAAC;KACnB;IAED,oCAAoC;IACpC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAClC,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;KAC9B;IAED,wDAAwD;IACxD,OAAO,mBAAS,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;AAC7C,CAAC","sourcesContent":["import { stringify } from \"flatted\";\nimport stripIndent from \"strip-indent\";\n\n// list of possible simple values\ntype ConcatenatableToken = object | string | number | undefined;\n\n// concatenatable item is either a simple value or a promise of one\ntype ConcatenatableItem = ConcatenatableToken | Promise<ConcatenatableToken>;\n\n// concatenatable is either a concatenatable item or an array of them\ntype Concatenatable = ConcatenatableItem | ConcatenatableItem[];\n\n// html tag function, accepts simple values, arrays, promises\nexport default function html(template: TemplateStringsArray, ...expressions: Concatenatable[]): string {\n  let result = \"\";\n  let i = 0;\n\n  // resolve each expression and build the result string\n  for (const part of template) {\n    const expression = expressions[i++ - 1]; // this might be an array\n    const resolvedExpression = resolveExpression(expression);\n\n    result += `${resolvedExpression}${part}`;\n  }\n\n  // strip indentation and trim the result\n  return stripIndent(result).trim();\n}\n\n// returns whether given value is likely a promise\n// tslint:disable-next-line:no-any\nfunction isPromise<T>(p: any): p is Promise<T> {\n  return p !== undefined && p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n// resolves a concatenatable expression to a string (async)\nfunction resolveExpression(expression: Concatenatable): string {\n  // return empty string for undefined\n  if (expression === undefined) {\n    return \"\";\n  }\n\n  // return placeholder for promise\n  if (isPromise<ConcatenatableToken>(expression)) {\n    // recursively resolve\n    return \"[promise]\";\n  }\n\n  // return placeholder for function\n  if (typeof expression === \"function\") {\n    return \"[function]\";\n  }\n\n  // handle arrays\n  if (Array.isArray(expression)) {\n    const items: ConcatenatableToken[] = [];\n\n    // resolve each item (might be promises as well)\n    for (const expressionItem of expression) {\n      items.push(resolveExpression(expressionItem));\n    }\n\n    // join with newline\n    return items.join(\"\\n\");\n  }\n\n  // return unmodified if got a string\n  if (typeof expression === \"string\") {\n    return expression;\n  }\n\n  // convert to string if got a number\n  if (typeof expression === \"number\") {\n    return expression.toString();\n  }\n\n  // return stringified value, handles circular references\n  return stringify(expression, undefined, 2);\n}\n"]}},"error":null,"hash":"bb96adfd1bebdaa8bd6674429c9c6fc7","cacheData":{"env":{}}}